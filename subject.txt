EXTERNAL FUNCTIONS: malloc, free, write, open, read, close, fork, wait,
		    waitpid, wait3, wait4, signal, kill, exit, getcwd,
		    chdir, stat, lstat, fstat, execve, dup, dup2, pipe,
		    opendir, readdir, closedir, strerror, errno

YOUR SHELL SHOULD:  Show a prompt when waiting for new command
		    Search and launch the right executable (based on the PATH
		      variable or by using relative or absolute path) like in bash
		    It must implement the builtins like in bash:
		      echo with option '-n'
		      cd with only a relative or absolute path 
		      pwd without any options
		      export without any options
		      unset without any options
		      env without any options
		      exit without any options
		    ';' in the command should seperate commands like bash
		    ' and " should work like bash except for multiline commands
		    Redirections '< > << >>' should work like in bash EXCEPT for
		      file descriptor aggregation
		    Pipes '|' should work like in bash
		    Enviorment variables ($ followed by characters) should work
		      like in bash
		    #? should work like in bash
		    [CTRL]-c, [CTRL]-d, and [CTRL]-\ should have the same result
		      as in bash

FUNCTIONS:
  wait: http://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/wait.html
  The system call wait() is easy. This function blocks the calling process until one of its child processes exits or a signal is
    received. For our purpose, we shall ignore signals. wait() takes the address of an integer variable and returns the process
    ID of the completed process. Some flags that indicate the completion status of the child process are passed back with
    the integer pointer. One of the main purposes of wait() is to wait for completion of child processes.

  The execution of wait() could have two possible situations.

  If there are at least one child processes running when the call to wait() is made, the caller will be blocked until one of its
    child processes exits. At that moment, the caller resumes its execution.
  If there is no child process running when the call to wait() is made, then this wait() has no effect at all.
    That is, it is as if no wait() is there.

  The main program creates two child processes to execute the same printing loop and display a message before exit.
    For the parent process (i.e., the main program), after creating two child processes, it enters the wait
    state by executing the system call wait(). Once a child exits, the parent starts execution and the ID of the
    terminated child process is returned in pid so that it can be printed. There are two child processes and thus two wait()s,
    one for each child process. In this example, we do not use the returned information in variable status.
__________________________________________________________________________________________________________
  dup: https://www.geeksforgeeks.org/dup-dup2-linux-system-call/
  SYNTAX: int dup(int oldfd);
  The dup() system call creates a copy of a file descriptor.
    It uses the lowest-numbered unused descriptor for the new descriptor.
    If the copy is successfully created, then the original and copy file descriptors may be used
      interchangeably.
    They both refer to the same open file description and thus share file offset and file status flags.
__________________________________________________________________________________________________________
  fork: https://www.geeksforgeeks.org/fork-system-call/
  Fork system call is used for creating a new process, which is called child process, which runs concurrently with the process
    that makes the fork() call (parent process). After a new child process is created, both processes will execute the next
    instruction following the fork() system call. A child process uses the same pc(program counter), same CPU registers,
    same open files which use in the parent process.

  It takes no parameters and returns an integer value. Below are different values returned by fork().

  Negative Value: creation of a child process was unsuccessful.
  Zero: Returned to the newly created child process.
  Positive value: Returned to parent or caller. The value contains process ID of newly created child process.
__________________________________________________________________________________________________________

  getcwd: https://man7.org/linux/man-pages/man3/getcwd.3.html
  get current working directory
----------------------------------------------------------------------------------------------------------

  chdir: https://www.geeksforgeeks.org/chdir-in-c-language-with-examples/
  The chdir command is a system function (system call) which is used to change the current working directory.
    On some systems, this command is used as an alias for the shell command cd. chdir changes the current working
    directory of the calling process to the directory specified in path.

  SYNTAX: int chdir(const char *path);
  Parameter: Here, the path is the Directory path which the user want to make the current working directory.
  Return Value: This command returns zero (0) on success. -1 is returned on an error and errno is set appropriately.

----------------------------------------------------------------------------------------------------------
  stat: shorturl.at/yM046
  used to list properties of a file identified by path. It reads all file properties and dumps to buf
    structure.
  Here *path is a pointer to constant character pointing to file path. *buf is a stat type structure
    defined in sys/stat.h.
  On success the function returns 0 and fills the buf structure with file properties. On error the
    function return -1 and sets error code. You can use this function to get various properties of a file.

----------------------------------------------------------------------------------------------------------
  execve: shorturl.at/DHR19
  SYNTAX: int execve(const char *file, char *const argv[], char *const envp[]);
  Like all of the exec functions, execve replaces the calling process image with a new process image.
    This has the effect of running a new program with the process ID of the calling process.
    Note that a new process is not started; the new process image simply overlays the original process
    image. The execve function is most commonly used to overlay a process image that has been created by
    a call to the fork function.
  RETURN VALUE: A successful call to execve does not have a return value because the new process image
    overlays the calling process image. However, a -1 is returned if the call to execve is unsuccessful.
----------------------------------------------------------------------------------------------------------

